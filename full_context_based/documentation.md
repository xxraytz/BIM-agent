## Документация по Text-to-SQL пайплайну с использованием Google Gemini

### 1. Общее описание

Этот проект представляет собой продвинутый Text-to-SQL пайплайн, предназначенный для преобразования вопросов пользователя, заданных на естественном языке (например, "Какая общая площадь всех стен?"), в исполняемые SQL-запросы к базе данных SQLite.

Основная цель — предоставить экспертный ответ на основе данных из базы, связанной со строительством и BIM-моделями (Building Information Modeling).

**Ключевые особенности:**

*   **Многоэтапная логика:** Пайплайн не просто генерирует SQL, а выполняет серию шагов: сначала определяет релевантные таблицы, затем пишет запрос, выполняет его, семантически проверяет результат и, при необходимости, итеративно исправляет ошибки.
*   **Самокоррекция:** Если SQL-запрос возвращает ошибку или семантически некорректный результат (например, пустой ответ, где он не ожидается), система автоматически пытается исправить запрос, используя информацию об ошибке.
*   **Использование Pydantic:** Для структурирования вывода от LLM (языковой модели) используются Pydantic-модели, что делает взаимодействие с моделью более надежным и предсказуемым.
*   **Форматирование ответа:** Финальный результат представляется не в виде сырых данных, а как связный и понятный ответ от лица "эксперта по строительству" на русском языке.
*   **Модель:** В качестве LLM используется `gemini-2.5-flash` от Google.

### 2. Архитектура проекта

Проект состоит из двух основных файлов:

1.  `templates.py`: **"Библиотека промптов"**. Этот файл содержит все шаблоны запросов (промпты) к языковой модели. Он определяет, *какие инструкции* получит LLM на каждом шаге. Здесь же определены Pydantic-модели для парсинга ответов модели.
2.  `core.py`: **"Исполнительный движок"**. Этот файл содержит всю логику пайплайна. Он управляет последовательностью вызовов к LLM, взаимодействует с базой данных, обрабатывает ошибки и координирует весь процесс от получения вопроса до выдачи финального ответа.

### 3. Необходимые файлы и их назначение

Для корректной работы скрипта в корневой директории должны находиться следующие файлы:

*   `core.py`: Основной исполняемый файл.
*   `templates.py`: Модуль с шаблонами промптов.
*   `database.sqlite`: Файл базы данных SQLite, к которой будут выполняться запросы.
*   `db_description.txt`: Текстовый файл, содержащий описание схемы базы данных (структура таблиц, колонки, возможные связи). Этот файл используется LLM для понимания контекста БД.
*   `questions.json`: JSON-файл со списком вопросов для пакетной обработки. Пример: `[{"question": "Твой вопрос здесь"}]`.

### 4. Установка и запуск

#### 4.1. Необходимые библиотеки

Для работы проекта требуются следующие Python-библиотеки. Создайте файл `requirements.txt` с таким содержимым:

```txt
pandas
langchain
langchain-google-genai
pydantic
google-api-python-client
```

Установите их с помощью pip:

```bash
pip install -r requirements.txt
```

#### 4.2. Ключ API

Для работы с моделью Gemini вам понадобится ключ API от Google AI Studio.

1.  Получите ключ на сайте [Google AI Studio](https://aistudio.google.com/app/apikey).
2.  Скрипт попытается получить ключ из переменной окружения `GOOGLE_API_KEY`. Вы можете установить её в вашей системе:
    *   **Windows (PowerShell):** `$env:GOOGLE_API_KEY="ВАШ_КЛЮЧ"`
    *   **Linux/macOS:** `export GOOGLE_API_KEY="ВАШ_КЛЮЧ"`
3.  Если переменная окружения не установлена, скрипт запросит ввод ключа в консоли при запуске.

#### 4.3. ВАЖНО: Использование VPN

На данный момент (июнь 2024 года) **API Google Gemini недоступен для пользователей с российскими IP-адресами**. Для успешной работы скрипта необходимо использовать VPN-сервис с серверами, расположенными в странах, где доступ к API разрешен (например, США или страны Европы). Без VPN вызовы к LLM будут завершаться с ошибкой подключения.

#### 4.4. Запуск скрипта

После установки библиотек, настройки ключа API и включения VPN, запустите главный файл из терминала:

```bash
python core.py
```

Скрипт последовательно обработает все вопросы из `questions.json` и выведет в консоль подробный лог выполнения и финальный результат для каждого вопроса.

### 5. Логика работы пайплайна (детально)

Процесс обработки одного вопроса (`run_pipeline`) состоит из следующих шагов:

1.  **Идентификация релевантных таблиц (`identify_relevant_tables`)**
    *   **Цель:** Сузить область поиска, чтобы не передавать LLM информацию обо всей базе данных.
    *   **Процесс:** Пользовательский вопрос и схема БД (`db_description.txt`) отправляются модели с инструкцией определить, какие таблицы наиболее важны для ответа.
    *   **Результат:** Список имен таблиц (например, `['IfcWall', 'IfcPropertySet']`).

2.  **Генерация SQL-запроса (`generate_sql`)**
    *   **Цель:** Создать один или несколько SQL-запросов для извлечения необходимых данных.
    *   **Процесс:** Модели передается схема БД, вопрос пользователя и, что важно, **несколько первых строк (`PREVIEW_ROWS`)** из ранее определенных релевантных таблиц. Это помогает модели лучше понять реальные данные и избежать ошибок в именах колонок или форматах данных.
    *   **Результат:** Список объектов `Query`, каждый из которых содержит цель, аннотацию и сам SQL-код.

3.  **Выполнение и оценка запроса (`execute_and_evaluate`)**
    Это самый сложный и важный этап, который выполняется для каждого сгенерированного запроса.

    *   **3.1. Выполнение SQL:** Скрипт пытается выполнить SQL-запрос к базе данных `database.sqlite` с помощью `pandas`.
    *   **3.2. Обработка ошибок:**
        *   **SQL-ошибка:** Если возникает ошибка синтаксиса или выполнения (`DatabaseError`), она перехватывается.
        *   **Пустой результат:** Если запрос выполнился, но вернул пустой результат (`[]`, `{}`, `null`), это рассматривается как потенциальная семантическая ошибка.
    *   **3.3. Семантическая проверка (`semantic_check_prompt_template`):**
        *   Если запрос вернул данные, они вместе с самим запросом и его целью отправляются модели для проверки на "здравый смысл". Например, если вопрос был о площади этажа, а результат `0` или `null`, модель пометит это как семантически неправдоподобный ответ.
        *   **Результат:** `state: true/false` и аннотация.
    *   **3.4. Цикл исправления:**
        *   Если на шаге 3.2 или 3.3 возникла проблема, запускается функция `fix_sql`.
        *   В `fix_sql` модели передается вся информация о проблеме: исходный вопрос, "сломанный" SQL, текст ошибки и превью таблиц.
        *   Модель генерирует исправленный SQL-запрос.
        *   Процесс возвращается на шаг 3.1 с новым запросом.
        *   Этот цикл может повториться до `MAX_ITERATIONS` раз (по умолчанию 5), чтобы предотвратить бесконечные попытки.

4.  **Форматирование финального ответа (`formalizing_response`)**
    *   **Цель:** Преобразовать сырые данные (обычно в формате JSON), полученные из БД, в читаемый ответ.
    *   **Процесс:** Итоговые данные и исходный вопрос пользователя отправляются модели с инструкцией сформулировать исчерпывающий и профессиональный ответ на русском языке от лица эксперта в строительстве.
    *   **Результат:** Финальный текстовый ответ для пользователя.